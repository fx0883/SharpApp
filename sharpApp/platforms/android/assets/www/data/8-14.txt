Ruby代码可以方便的移植，也可以方便的对原代码进行分发。这样带来了灵活性的同时也带来了巨大的隐患，如何才能防止不安全代码的执行呢？
	我们可以利用Ruby语言含有的安全控制功能来实现这一目标。Ruby安全控制可以用来锁住有嫌疑的数据，这样的数据被称作“tainted”。Ruby安全控制系统引入了一种机制，可以由用户决定如何处理有潜在危险的数据。
	全局变量$SAFE用来控制安全级别。默认的级别是0。可以通过改变$SAFE的值或使用命令行参数-T来指定安全级别。安全级别数值越低表示数据越可信。数值低的安全级别的约束同样对数值高的安全级别起作用。不能在代码中降低当前安全级别。
$SAFE	约束
0	不对tainted数据作检验，是Ruby的默认安全级别
1	不允许有危险的操作使用tainted数据
2	不允许加载可写路径之外的代码
3	所有新建立的对象都被认为是tainted数据
4	将tainted数据和非tainted数据隔离开，非tainted数据不允许改变
	新建立的线程会继承当前$SAFE的值。在新建立的线程中，可以改变$SAFE的值而并不影响其它线程。这样可以容易的实现“沙箱”的功能。例如在一个线程中，当需要从外部加载代码并加以执行时，可以通过降低$SAFE的值来限制代码执行一些有危险的操作，从而降低代码的潜在风险。
	什么是tainted数据？简单的说，就是这个数据受到了污染而变得不可信。当一个Ruby对象起源自一些外部资源，例如一个字符串保存了被读取外部文件的内容，这个对象被自动标记为“tainted”。如果使用这个tainted对象而得到其他的对象，那么这个新得到的对象也被标记为“tainted”。可以使用Object#tainted?方法来判断一个对象是否被“tainted”。
	
	str1 = "This is a string"
	str1.tainted?				#=> false
	
	str2 = str1 + “!”
	str2.tainted?				#=> false
	str3 = gets	#str1的值从输入流读取
	str3.tainted? 			#=> true
	str4 = str3 + “!”
	str4.tainted? 			#=> true
	可以看到，由于str3的内容来自外部，所谓str3被认为是不可信的，对str3作操作的结果同样被认为不可信的。
	
§14.1  0级
	0级是默认的安全级别，不对tainted数据作任何检查。环境变量PATH的值会被检查，只有PATH内包含的目录对所有人都可写PATH才会被置为tainted。 其他任何来自IO的数据，环境变量和ARGV自动被标记为tainted。
§14.1  1级
对tainted数据有潜在危险的操作被禁止。这一级别适合用来处理输入包含一些不可信的数据，例如CGI程序。
§14.2  2级
除了1级的约束之外，对文件有潜在危险的操作被禁止。
§14.3  3级
除了2级的约束之外，所有新产生的对象都被标记为tainted。
§14.4  4级
除了3级的约束之外，不能改变全局变量的值。